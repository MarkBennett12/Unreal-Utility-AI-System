Default (GPT-3.5)
User
Hello Chat GPT. I am developing an application in Unreal Engine 4.27 using both C++ and Blueprint. The application is an implementation of Utility AI. My architecture is as follows. I have an ActorComponent inheriting from UActorComponent. This contains a BlueprintReadWrite property which is a TArray of type UUtilityActionBase which is a Blueprintable class inheriting from UObject. Individual actions will be created in Blueprint and assigned to this array. The action class contains a property of type UInsistenceSatisfaction which also inherits from UObject. This will also contain a Bleuprint inheriting from UInsistenceSatisfaction. UInsistenceSatisfaction contains a property of type float represeting the actions insistence satisfaction. This class also contains an overridable C++ function which can be used to specialse the insistence satisfaction value in the Blueprint child class of UInsistenceSatisfaction. I have attached my source code below.
UMyUtilityAIComponent class header
UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class MYUTILITYAIPROJECT_API UMyUtilityAIComponent : public UActorComponent
{
	GENERATED_BODY()

	//AActor* ParentActor;

public:	
	// Sets default values for this component's properties
	UMyUtilityAIComponent();

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditorCategory)
	TArray<FInsistence> Insistences;

	UPROPERTY(BlueprintReadOnly)
	FInsistence MaxInsistence;

	// we need to store both the classes and pointers to the action instances, hence the two data structures
	// I'm hoping to find a better way to do this, maybe editor only
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditorCategory, meta = (ExposeOnSpawn = "true"))
	TSet<TSubclassOf<UUtilityActionBase>> ActionClasses;

	// the pointers to the actual instances
	UPROPERTY()
	TArray<UUtilityActionBase*> ActionInstances;

private:
	//UPROPERTY()
	UUtilityActionBase* CurrentAction;

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

	// return an insistence struct by insistence name
	UFUNCTION(BlueprintPure, Category = EditorCategory)
	void GetInsistenceByName(const FName name, FInsistence& insistence, bool& success);

	// return insistance value from insistence name
	UFUNCTION(BlueprintPure, Category = EditorCategory)
	void GetInsistenceValueByName(const FName name, float& insistenceValue, bool& success);

	// set the insistance value by insistence name
	UFUNCTION(BlueprintCallable, Category = EditorCategory)
	void SetInsistenceValueByName(const FName name, float insistenceValue, float& newInsistenceValue, bool& success);

	// Check if an insistence exists in the utility component
	UFUNCTION(BlueprintPure, Category = EditorCategory)
	bool HasInsistance(const FName name);

	UFUNCTION(BlueprintPure, Category = EditorCategory)
	UUtilityActionBase* GetCurrentAction();

	void UpdateBestAction();
};
UUtilityActionBase class header
UCLASS(Blueprintable, Blueprintable)
class MYUTILITYAIPROJECT_API UUtilityActionBase : public UObject
{
	GENERATED_BODY()

public:
	UUtilityActionBase();

	void BeginPlay();

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditorCategory)
	FName ActionName;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditorCategory)
	TSubclassOf<UInsistenceSatisfaction> InsistenceSatisfactionClass;
	UInsistenceSatisfaction* InsistenceSatisfaction;

	// Blueprint event for the user to implement thier action logic
	UFUNCTION(BlueprintImplementableEvent, Category = EditorCategory)
	void OnTick(float DeltaTime);

	// so we can get access to whatever actor owns the utilty AI component
	UPROPERTY(BlueprintReadOnly)
	AActor* OwningActor;

	void Tick(float DeltaTime);

	// Need this so we can access the UE4 gameplay framework in the action Blueprints
	virtual class UWorld* GetWorld() const override;
};
UInsistenceSatisfaction class header
UCLASS(BlueprintType, Blueprintable)
class MYUTILITYAIPROJECT_API UInsistenceSatisfaction : public UObject
{
	GENERATED_BODY()
public:
	UInsistenceSatisfaction();
	~UInsistenceSatisfaction();

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = EditorCategory)
	FName InsistenceName = "";
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = EditorCategory)
	float BaseSatisfactionValue = 0;

	// Need this so we can access the UE4 gameplay framework in the action Blueprints
	virtual class UWorld* GetWorld() const override;

	void BeginPlay();

	UFUNCTION(BlueprintNativeEvent, Category = EditorCategory)
	float GetSatisfationValue();
	float GetSatisfationValue_Implementation();

	UPROPERTY(BlueprintReadOnly)
	AActor* OwningActor;
};
GetSatisfationValue implementation
float UInsistenceSatisfaction::GetSatisfationValue_Implementation()
{
	return BaseSatisfactionValue;
}
I have verified that the overriden function works, and also that non-overriden versions of the function work. However, I am experiencing an intermittent exception. The exception details are below.
Exception thrown at 0x0000001500000015 in UE4Editor-Win64-DebugGame.exe: 0xC0000005: Access violation executing location 0x0000001500000015.
Would you be able t5o help me find the cause of this error
ChatGPT

The "Access violation" exception you are encountering is a common runtime error in C++ applications and typically indicates that your code is trying to access memory that it does not have permission to access. This can happen for various reasons, such as dereferencing a null or invalid pointer, accessing an array out of bounds, or trying to use an object that has been deleted or is in an invalid state. In your code, there are several possibilities for where this issue may be occurring.

Here are some steps you can follow to identify and fix the issue:

    Check the Call Stack:
    When the exception occurs, check the call stack in your debugger to see which function or line of code triggered the access violation. This will give you a clue about where to start investigating.

    Check for Null Pointers:
    Ensure that you are not dereferencing null or invalid pointers. In your code, you have several pointer variables, such as InsistenceSatisfaction, OwningActor, and ActionInstances. Make sure these pointers are properly initialized before accessing them.

    Array Bounds and Indexing:
    Be careful when accessing arrays and indices. Make sure you are not going out of bounds in any of your arrays or collections. An array index that is too large or negative can lead to access violations.

    Object Lifetime:
    Ensure that the objects you are working with are still valid when you access them. In particular, consider the lifetime of your UInsistenceSatisfaction and UUtilityActionBase instances.

    Blueprint Implementations:
    Since you have Blueprint-implemented functions and properties, make sure that the Blueprint logic does not introduce issues that lead to access violations. Check your Blueprint graphs for potential problems.

    Debugging Tools:
    Use Unreal Engine's debugging tools, such as breakpoints, watches, and logging, to narrow down the location of the exception. You can also enable the "Null Check" and "Range Check" options in the Unreal Engine editor preferences for better runtime checks.

    Handle Special Cases:
    Look into any custom implementations in your code that may be causing the exception. In your GetSatisfationValue_Implementation function, ensure that the BaseSatisfactionValue variable is valid.

    Code Review:
    Review your code for potential logical errors or typos that could lead to memory access issues.

Debugging access violations can be complex, and it often requires a step-by-step investigation. By following these steps and examining the specific circumstances in which the exception occurs, you can isolate the issue and fix it. If the problem persists, consider providing more specific information about the location in your code where the exception is thrown for more targeted assistance.
User
using the call stack I have established that the function causeing the problem is GetSatisfationValue();
ChatGPT

If you have identified that the issue is occurring within the GetSatisfationValue function in your UInsistenceSatisfaction class, you can focus your debugging efforts on this specific function. Since this is a Blueprint-native function, there may be an issue with the way it's implemented in Blueprint. Here are some steps to further investigate and resolve the problem:

    Blueprint Implementation:
    Review the implementation of the GetSatisfationValue function in your Blueprint. Ensure that it's correctly implemented as a Blueprint Native Event. Make sure that the function is returning a float value and that there are no errors or warnings in the Blueprint.

    Check Blueprint Variables:
    Verify that any Blueprint variables or properties used within the GetSatisfationValue function are properly set and have valid values. This includes checking the value of BaseSatisfactionValue and any other Blueprint-specific variables.

    Blueprint Logs and Debugging:
    Add print nodes or logs to your Blueprint to track the execution flow and the values of relevant variables within the GetSatisfationValue function. This can help you identify if there are any unexpected values or conditions causing the access violation.

    Blueprint Event Execution:
    Ensure that the GetSatisfationValue function is not being called in a way that conflicts with the expected execution flow. Double-check any Blueprint graphs or logic that might be calling this function.

    Validate Inputs:
    If BaseSatisfactionValue is set by Blueprint, validate that it is set correctly and that it contains a valid float value.

    Examine Dependencies:
    Investigate if there are any dependencies or interactions with other Blueprint classes or C++ code that might influence the behavior of GetSatisfationValue.

By carefully examining the Blueprint implementation of GetSatisfationValue and its interactions, you can pinpoint the cause of the access violation. Additionally, you may want to use Unreal Engine's debugging tools, such as printing to the output log or using breakpoints in your Blueprint graph, to trace the execution flow and inspect variable values at runtime. This will help you identify the specific issue causing the access violation within the Blueprint logic.
User
I have disconnected all the Blueprint code in the overriden GetSatisfationValue function so that it is only returning zero. The exception still occurs. From this I conclude that the Blueprint code is not the problem
ChatGPT

If the exception is still occurring even after you've removed the Blueprint code from the overridden GetSatisfationValue function and it's just returning zero, it suggests that the issue might be related to the C++ side of your code. Given that this function is part of your C++ class, there are a few things you can investigate:

    Check for Invalid Pointers:
    Ensure that there are no invalid pointers or memory issues within your GetSatisfationValue function. Verify that the UInsistenceSatisfaction object and other pointers used within the function are properly initialized.

    Investigate the Call Stack:
    Examine the call stack to see if there are any C++ functions or methods calling your GetSatisfationValue function. This can help identify the exact location in your C++ code where the access violation is occurring.

    Object Lifetime:
    Double-check the lifetime of the UInsistenceSatisfaction objects and any other related objects. Ensure that they are not being destroyed prematurely or accessed after they have been deleted.

    Shared Data:
    If there's shared data between different parts of your code, investigate if there are race conditions or conflicts that might be causing the issue.

    Unreal Engine's Debugging Tools:
    Use Unreal Engine's debugging tools, such as breakpoints and watches, to examine the state of variables and objects within your C++ code. You can use these tools to step through the code and identify the point of failure.

    Memory Corruption:
    In some cases, memory corruption can lead to intermittent access violations. Check for any memory-related issues in your code, such as buffer overflows or invalid memory operations.

    Check for Exception Handling:
    Ensure that your C++ code handles exceptions gracefully. If an exception occurs within your GetSatisfationValue function, it should be properly caught and handled to prevent a crash.

By carefully inspecting your C++ code, debugging the issue, and examining the call stack, you should be able to pinpoint the exact location and cause of the access violation. It might also be beneficial to seek assistance from Unreal Engine forums or communities where experienced developers can help diagnose and resolve such issues in Unreal Engine projects.
User
using the call stack I have established that all the UInsistenceSatisfaction members have valid values although I did notice that the UObject Name property is None
ChatGPT

The fact that the UObject Name property is None may be a clue to the issue you're facing. In Unreal Engine, UObject names are typically expected to be valid and unique, and a None name could indicate a problem. While it's not uncommon for some UObjects to have a None name, depending on how they are created and managed, it might still be relevant to the specific situation.

Here are some steps to consider regarding the None name property:

    UObject Name:
    Review how the UInsistenceSatisfaction objects are being created and named. Ensure that the name property is set correctly during the object's initialization or creation.

    Object Creation:
    Check the code where you create instances of UInsistenceSatisfaction objects. Ensure that the objects are being created with appropriate names, and that the names are not accidentally set to None.

    Naming Conventions:
    Make sure that you are following naming conventions and not accidentally setting names to an empty or None value.

    Default Object Name:
    For some UObject instances, it's normal for their name property to be None, especially for objects that don't require a unique name. However, this should not typically cause an access violation.

    Logging and Debugging:
    To gain more insight into when and how the name property is set, you can add logging or debugging statements to track the creation and naming of UInsistenceSatisfaction objects.

    Object Initialization:
    Ensure that any initialization or setup of the UInsistenceSatisfaction objects is done correctly, including the assignment of the name property.

If, after investigating the name property, you're still unable to resolve the access violation, it may be beneficial to consult the Unreal Engine community or forums, as other developers with experience in Unreal Engine may have encountered similar issues and can provide additional guidance or suggestions for debugging and fixing the problem.
User
I attempted to watch the function call action->InsistenceSatisfaction->GetSatisfationValue() and this aborted due to an unhandled exception
ChatGPT

The fact that the debugger is aborting due to an unhandled exception when trying to watch action->InsistenceSatisfaction->GetSatisfationValue() is a significant clue. It suggests that there's an issue within the GetSatisfationValue function itself or within the InsistenceSatisfaction object.

Here are some additional steps to investigate and resolve the issue:

    Double-Check GetSatisfationValue:
    Review the GetSatisfationValue function in the UInsistenceSatisfaction class carefully. Ensure that it's correctly defined and implemented without any issues. Pay special attention to its return type, which should match the expected type of the function.

    Verify InsistenceSatisfaction:
    Before calling GetSatisfationValue, double-check that the InsistenceSatisfaction object (UInsistenceSatisfaction) is valid. Ensure that it's properly initialized and not a null or invalid object.

    UObject Initialization:
    Ensure that the UInsistenceSatisfaction object is being initialized properly. The UObject lifecycle in Unreal Engine is sensitive, and the order of object creation and initialization can be critical.

    Default Implementation:
    If there's a default implementation of GetSatisfationValue in your C++ class, verify that it doesn't introduce any issues or conflicts with the Blueprint implementations.

    Blueprint Overrides:
    Check if you have any Blueprint child classes of UInsistenceSatisfaction that override the GetSatisfationValue function. Ensure that the override is implemented correctly and doesn't introduce errors.

    Blueprint Interfaces:
    If UInsistenceSatisfaction is part of a Blueprint interface, double-check that all Blueprint classes implementing the interface provide a valid implementation for GetSatisfationValue.

    Debug Logs:
    Insert debug logs or print statements within the GetSatisfationValue function to see if it's being called and to log any relevant values or operations within the function.

    Exception Handling:
    Implement proper exception handling in your code, especially when working with Unreal Engine, to gracefully catch and handle any exceptions that may occur. This can help prevent crashes and provide more detailed error messages.

    Check the Blueprint Graph:
    If you have Blueprint nodes calling the GetSatisfationValue function, review the associated Blueprint graph for any unusual or problematic connections, variable values, or logic.

If the issue persists and the debugger is aborting with an unhandled exception, it indicates that there's likely a problem within the GetSatisfationValue function or with the InsistenceSatisfaction object itself. Carefully inspect your code and debugging tools to pinpoint the exact cause of the exception, and consider seeking assistance from the Unreal Engine community or forums, as other developers may have encountered similar issues and can offer specific guidance for your project.
User
Thank you for your help I will consult the community
ChatGPT

You're welcome! Consulting the Unreal Engine community is a great idea, as they can provide specific guidance and insights into the issue you're facing in your project. They may have encountered similar problems and can offer valuable assistance.

If you have any more questions or need further assistance in the future, feel free to return. Good luck with resolving the issue in your project, and I hope you find a solution with the help of the community!
Free Research Preview. ChatGPT may produce inaccurate information about people, places, or facts. ChatGPT September 25 Version